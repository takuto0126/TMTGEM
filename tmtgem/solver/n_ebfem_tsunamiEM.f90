!# Dec 02, 2021, Nested grid is covered in TMTGEM with version 1.3
!# Taking into account the curvature of the Earth is supported on 2016.11.20
!# coded on May 16, 2016
!# to calculate EM fields generated by tsunamis
!# using edge-FEM in the time domain
!#
program n_ebfem_tsunamiEM
use param
use param_mesh
use matrix
use iccg_var_takuto
use mesh_type
use line_type
use matrix
use fromcomcot
use obs_type     ! see m_obs_type.f90
use solvePARDISO
use constants
use oceanFvxyz   ! see m_oceanFvxyz.f90
use spherical    ! see m_spherical.f90, added on 2016.11.19
use divroterror  ! 2017.10.25
use caloceancond ! 2018.11.13 m_caloceancond.f90
implicit none
!include "../flat_gebco/meshpara.f90" ! inserted on Oct. 25, 2015
! Time flow, modified for COMCOT, on Oct. 25, 2015
!
!       bz0                                    (t=-5s)
! it=1  |  <-    M, N   (t=0)    m_01_000000.dat, n_01_000000.dat
!       bz1          |                         (t=5s)
! it=2  |  <-    M, N   (t=10s)  m_01_000010.dat, n_01_000010.dat
!       bz2          |                         (t=15s)
!## for global mesh ###
type(param_forward)                    :: g_param    ! see m_param.f90
type(meshpara)                         :: g_meshpara ! see m_param_mesh.f90
type(ocean_data)                       :: h_ocean    ! see m_oceanFvxyz.f90
type(comcot_data)                      :: h_comcot   ! see m_oceanFvxyz.f90
type(mesh)                             :: em_mesh    ! see m_mesh_type.f90
type(mesh)                             :: ki_mesh    ! 2021.07.27
type(line_info)                        :: l_line     ! see m_line_type.f90
type(global_matrix)                    :: A          ! see m_iccg_var_takuto.f90
type(PARDISO_PARAM)                    :: B
type(obs_info)                         :: obs_xy, obs_yz, obs_sites
type(error)                            :: e_divrot   ! see m_divroterr.f90 2017.10.26
real(8),   allocatable, dimension(:)   :: fsn0,fsn1,fsn2,fse,b_vec
real(8),   allocatable, dimension(:,:) :: exyz,bxyz
real(8),   allocatable, dimension(:,:) :: bxyz_yz,bxyz_xy,exyz_xy
real(8),   allocatable, dimension(:,:) :: bxyz_sites,exyz_sites ! 2021.07.26
real(8),   allocatable, dimension(:,:) :: vfxyz_sites,exyz_total_sites ! 2021.07.26
integer(4),allocatable, dimension(:)   :: igroup
integer(4),allocatable, dimension(:,:) :: table_dof
integer(4)          :: nline  ! for ocean.msh, nodes3 is added on Oct. 26, 2015
integer(4)          :: dofn=1, it,itmax, ip=0,i,j,jj, iflag_velocity,ntet
integer(4)          :: iflag = 0 ! output coordinate file  2018.11.14
character(70)       :: meshctlfile
real(8)             :: dt,tstart
integer(4)          :: icalerrflag  ! 2017.10.26

!#[0]## read parameters
  CALL READPARAM(g_param)            ! see m_param.f90
       tstart         = g_param%tstart
       dt             = g_param%dt
       itmax          = g_param%tmax/dt
	  meshctlfile    = g_param%meshctlfile
	  iflag_velocity = g_param%iflag_velocity
       g_param%iflagspherical=1 ! 0 for normal, 1 for spherical, 2016.11.20
	  icalerrflag    = g_param%icalerrflag  ! 1 for err, 2 for cal, 3 for both

!#[0-1]##
  CALL READMESHPARA(g_meshpara,meshctlfile)     ! see m_param_mesh.f90
       g_param%lonorigin = g_meshpara%lonorigin ! 2016.11.20
       g_param%latorigin = g_meshpara%latorigin ! 2016.11.20
  CALL CALCARTESIANBOUND(g_meshpara)            ! see m_param_mesh.f90
  CALL OBSLONLAT2XYZ(g_param,g_meshpara)        ! see below, g_param%obsxyz is calculated

!#[1]## read mesh   2021.07.27
!#[1-1]# read global ocean/EM mesh informations
  CALL READMESH_TOTAL(em_mesh, g_param%em3dmsh) ! m_mesh_type.f90
  CALL GENXYZMINMAX(em_mesh,g_param)            ! cal g_param%xyzminmax
  CALL READLINE(g_param%linefile,l_line)        ! see m_line_type.f90
      ntet = em_mesh%ntet
      nline=l_line%nline ; write(*,*) "nline=",nline
      allocate (igroup(ntet))
      igroup(1:ntet)=em_mesh%n4flag(1:ntet,2) ! 1 for air, 2 for ocean, 3 for below seafloor

!#[1-2]# read ki_mesh and ki23dptr              ! 2021.07.27
  CALL READMESH_TOTAL(ki_mesh, g_param%pokimsh) ! 2021.07.27 read polygon_ki.msh
  CALL READKI23DPTR(g_param,ki_mesh)            ! 2021.07.27 read ki23dptr.dat, generate g_param%ki23dptr

!#[Ocean conductivity option]##                 ! 2018.11.13
  CALL GENOCEANPTR(h_ocean,em_mesh,g_param)     ! see m_oceanFvxyz.f90 2017.11.02
  CALL setoceancond(em_mesh,g_param,h_ocean)    ! m_caloceancond.f90 2018.11.13

!#[2]## allocate h_ocean, calculate nodes, em2oceanptr, ocean2emptr
  it = 0
  call prepareFxyz(h_ocean,em_mesh,g_param,g_meshpara)                ! h_ocean%Fxyz see m_oceanFvxyz.f90
  call preparevxyz(h_ocean,em_mesh,g_param,g_meshpara,it,dt,h_comcot) ! h_ocean%vxyz see m_oceanFvxyz.f90
  if ( icalerrflag .eq. 1 .or. icalerrflag .eq. 3) then  ! 2017.11.02
   call prepoceanele2column(g_param,em_mesh,h_ocean)     ! 2017.11.02
  end if                                                 ! 2017.11.02

!#[Spherical option]## added pm 2016.11.20
  if ( g_param%iflagspherical .eq. 1 ) then
   call meshxyz2xyzspherical(em_mesh,g_meshpara) ! gen em_mesh%lonlatalt and xyzspherical
   call vectorxyz2spherical(em_mesh%lonlatalt,h_ocean%Fxyz,em_mesh%node)
  end if

!#[3]## coefficient for surface E and B ## 2016.11.20 modified for spherical option
  !CALL PREPOBSCOEFF_YZ(em_mesh,l_line,obs_yz,g_param)
  if ( icalerrflag .ge. 2 ) then ! 2017.10.26
   if (g_param%ixyflag .eq. 1) CALL PREPOBSCOEFF_XY(    em_mesh,l_line,obs_xy,ki_mesh,g_param)
   if (g_param%ixyflag .eq. 2) CALL PREPOBSCOEFF_XYSBTM(em_mesh,l_line,obs_xy,ki_mesh,g_param)
                               CALL PREPOBSCOEFF(em_mesh,l_line,obs_sites,ki_mesh,g_param)
  end if ! 2017.10.26

!#[4]## prepare Global MATRIX Array
! allocate item_u, item_l, istack_u, istack_l, aiccg_u, aiccg_l, diag, x_vec, b_vec
! set item_u, item_l, istack_u, istack_l
  allocate( table_dof(nline,dofn))
  CALL SET_TABLE_DOF(dofn,nline,table_dof,nline)
  CALL set_iccg_var7_dofn(dofn,6,nline,nline,nline,em_mesh%ntet,l_line%n6line,table_dof,A,ip)
  deallocate(table_dof)

!#[5]## constract A and PARDISO factorise
  if ( icalerrflag .ge. 2 ) then ! 1 for err, 2 for cal, 3 for both
   CALL forward_LHS(A,em_mesh,l_line,igroup,dt,g_param)
   CALL PARDISOphase1(A,B) ! initialize, see m_solvePARDISO.f90
   CALL PARDISOphase2(B)   ! factolize, see m_solvePARDISO.f90
  end if

!#[5]## allocate variables for time evolution
  ! allocate (bxyz_yz(obs_yz%nobs,3),exyz_xy(obs_xy%nobs,3))
  allocate(  fsn0(nline),fsn1(nline),fsn2(nline), fse(nline),b_vec(nline) )
  allocate(  bxyz_xy   (obs_xy%nobs,   3), exyz_xy(obs_xy%nobs,3))
  allocate(  bxyz_sites(obs_sites%nobs,3), exyz_sites(obs_sites%nobs,3)) ! 2021.07.26
  allocate(  vfxyz_sites(obs_sites%nobs,3), exyz_total_sites(obs_sites%nobs,3)) ! 2021.07.26

!#[6]## time loop starts
  if ( icalerrflag .ge. 2 ) then ! 1 for err, 2 for cal, 3 for both 2017.10.26
   CALL OPENOBSFILE(obs_sites,g_param) ! modified on 2021.07.26 for output of electric field
  end if ! 2017.10.26
  if (icalerrflag .eq. 1 .or. icalerrflag .eq. 3) then
   CALL OPENERRFILE(g_param,e_divrot)
  end if ! 2017.10.26
   fsn0(1:nline)=0.d0
   do it =1,itmax
    write(*,*) "============= it=",it," START ================="
    if ( it .eq. 1) fsn1(1:nline)=0.d0 ;
    if ( it .ge. 2) then
     fsn0=fsn1 ! for second order Backward Euler added on July 19th, 2016
     fsn1=fsn2
    end if
    fsn2(:)=0.d0 !;   vxyz(:,:)=0.d0

!#[7]## calculate rhs vector, b_vec  (forward_rhs.f90)
     call preparevxyz(h_ocean,em_mesh,g_param,g_meshpara,it,dt,h_comcot) ! see m_oceanFvxyz.f90

     if ( icalerrflag .eq. 1 .or. icalerrflag .eq. 3 ) then !207.10.26
      call CALDIVROTERROR(em_mesh,h_ocean,e_divrot) ! m_divroterr.f90  2017.10.26
      call OUTEDIVROTERROR(e_divrot,it,dt)          ! m_divroterr.f90  2017.10.26
	call outdivrotudistribution(g_param,em_mesh,h_ocean,it)! m_divroterr.f90 2017.11.02
     end if

     if ( icalerrflag    .ge. 2  ) then ! 2017.10.26
     if ( g_param%iflagspherical .eq. 1  ) then
       call vectorxyz2spherical(em_mesh%lonlatalt,h_ocean%vxyz,em_mesh%node)
     end if
     end if ! 2017.10.26

!#[8]## right hand side and solve
     if (icalerrflag .ge. 2 ) then ! 2017.10.26
      CALL forward_rhs(A,em_mesh,h_ocean,l_line,b_vec,fsn0,fsn1,igroup,dt,it,g_param)
      CALL PARDISOphase3(B,b_vec,nline,fsn2)
     end if                        ! 2017.10.26
     !# calculate electric field E=-dA/dt
     fse=-(3.*fsn2 - 4.*fsn1 + fsn0)/2./dt  ! Second order backward Euler

!#[9]## calculate xy grid map data
   ! seafloor magnetic field: B=rotA
   ! CALL CALEB(obs_yz,fsn2,nline,bxyz_yz,2)
   if ( icalerrflag .ge. 2 ) then ! 2017.10.26
   if ( g_param%ixyflag .ge. 1 .and. mod(it,int(g_param%tinterval_xy/dt)) .eq. 0 ) then ! 2018.11.14
     !#[9-1]## bxyz
     CALL CALEB(obs_xy,fsn2,nline,bxyz_xy,2) ! when g_param%ixyflag = 1 or 2
     CALL EBXYZOUT(obs_xy,bxyz_xy,it,2,iflag,g_param)  ! output bxyz for obs 2018.11.14

     !#[9-2]## IXYH
     CALL CALEB(obs_xy,fse,nline,exyz_xy,1) ! exyz added on 2016.11.20
     CALL IXYHOUT(obs_xy,exyz_xy,h_ocean,it,g_param,iflag)
     !CALL EBXYZOUT(obs_xy,exyz,it,1)   ! output electric field

     !#[9-3]## vh and vz
     CALL OUTVXYZ(h_ocean, em_mesh, it,iflag,g_param) ! m_oceanFvxyz.f90 2018.11.14

     iflag = 1 ! no more coordinate file
   end if
   end if  ! 2017.10.26

!#[10]## cal site time series data
!  CALL EBXYZOUT(obs_yz,bxyz_yz,it,2)  ! commented out on July 16, 2016
   if ( icalerrflag .ge. 2 ) then ! 2017.10.26
    CALL CALEB(obs_sites,fsn2,nline,bxyz_sites,2) ! magnetic field
    CALL CALEB(obs_sites,fse, nline,exyz_sites,1) ! electric field added 2021.07.26
    CALL CALETOTAL(g_param,obs_sites,h_ocean,exyz_sites,vfxyz_sites,exyz_total_sites) ! 2021.07.26
    CALL BXYZOUT_TS(obs_sites,bxyz_sites,it,dt) ! TS : time series m_obs_type.f90
    CALL EXYZOUT_TS(obs_sites,exyz_sites,vfxyz_sites,exyz_total_sites,it,dt) ! TS : time series m_obs_type.f90 2021.07.26
   end if                         ! 2017.10.26

end do !# time loop end

if ( icalerrflag .ge. 2 ) CALL CLOSEOBSFILE(obs_sites) ! 2017.10.26
if ( icalerrflag .eq. 1 .or. icalerrflag .eq. 3 ) then ! 2017.10.26
 call CLOSEERRFILE(e_divrot)                           ! 2017.10.26
end if                                                 ! 2017.10.26

end program n_ebfem_tsunamiEM

!###################################################################
!# coded on 2021.07.27
subroutine READKI23DPTR(g_param,ki_mesh)
use mesh_type
use param
implicit none
type(mesh),          intent(in)    :: ki_mesh
type(param_forward), intent(inout) :: g_param
integer(4)                         :: ndat,i

g_param%nodek = ki_mesh%node ! # of node in polygon_ki.msh
allocate( g_param%ki23dptr(2,g_param%nodek) )

open(1,file=g_param%ki23dfile)
 read(1,*) ndat
 if ( ndat .ne. ki_mesh%node ) goto 99
 do i=1,ndat
  read(1,*) g_param%ki23dptr(1:2,i)
 end do
close(1)

return
99 continue
write(*,*) "GEGEGE! ndat=",ndat,"is not equal to nodek",g_param%nodek
stop
end
!###################################################################
! modified for spherical on 2016.11.20
! iflag = 0 for xyz
! iflag = 1 for xyzspherical
subroutine GENXYZMINMAX(em_mesh,g_param)
use param ! 2016.11.20
use mesh_type
implicit none
type(mesh),         intent(in)     :: em_mesh
type(param_forward),intent(inout)  :: g_param
real(8)                            :: xmin,xmax,ymin,ymax,zmin,zmax
real(8),allocatable,dimension(:,:) :: xyz
real(8)                            :: xyzminmax(6)
integer(4)                         :: i,node
node = em_mesh%node    ! 2018.11.16
allocate( xyz(3,node)) ! 2018.11.16
xyz  = em_mesh%xyz ! normal
xmin = xyz(1,1) ; xmax=xyz(1,1)
ymin = xyz(2,1) ; ymax=xyz(2,1)
zmin = xyz(3,1) ; zmax=xyz(3,1)

do i=1,em_mesh%node
 xmin=min(xmin,xyz(1,i))
 xmax=max(xmax,xyz(1,i))
 ymin=min(ymin,xyz(2,i))
 ymax=max(ymax,xyz(2,i))
 zmin=min(zmin,xyz(3,i))
 zmax=max(zmax,xyz(3,i))
end do

xyzminmax(1:6)=(/xmin,xmax,ymin,ymax,zmin,zmax/)

!# set output
g_param%xyzminmax = xyzminmax

write(*,*) "### GENXYZMINMAX END!! ###"
return
end
!###################################################################
subroutine CALEB(obs,fs,nline,bxyz,iebflag)
! iflag=1 -> electric field
! iflag=2 -> magnetic field
use matrix
use obs_type ! see m_obs_type.f90
implicit none
integer(4),    intent(in)    :: iebflag
type(obs_info),intent(in)    :: obs
integer(4),    intent(in)    :: nline
real(8),       intent(in)    :: fs(nline)
real(8),       intent(inout) :: bxyz(obs%nobs,3)
integer(4)                   :: i
!
do i=1,3 ! i-th component
 CALL mul_matcrs_rv(obs%coeff(iebflag,i),fs(1:nline),nline,bxyz(:,i))
end do
return
!
end

!###################################################################
!# coded on Jul 27, 2021
subroutine CALETOTAL(g_param,obs,h_ocean,exyz,vfxyz,exyz_total)
use oceanFvxyz   ! see m_oceanFvxyz.f90
use obs_type     ! see m_obs_type.f90
use outerinnerproduct
use param        ! m_param.f90
use spherical
implicit none
type(param_forward),intent(in)     :: g_param
type(ocean_data),   intent(in)     :: h_ocean
type(obs_info),     intent(in)     :: obs
real(8),            intent(in)     :: exyz(      obs%nobs,3)
real(8),            intent(inout)  :: vfxyz(     obs%nobs,3)
real(8),            intent(inout)  :: exyz_total(obs%nobs,3)
real(8),allocatable,dimension(:,:) :: Fxyz,vxyz,vF,vF_obs
integer(4)                         :: node,nobs,i

node           = h_ocean%node
nobs           = obs%nobs
allocate(Fxyz(3,node),vxyz(3,node),vF(3,node),vF_obs(3,nobs))
Fxyz           = h_ocean%Fxyz  ! [nT]
vxyz           = h_ocean%vxyz  ! [mm/sec]

!#[1]## calculate
do i=1,node
 vF(:,i)=outer(vxyz(:,i),Fxyz(:,i)) ! 10^-12 V/m
end do
call mul_matcrs_rv(obs%coeff_vF,vF(1,:),node,vF_obs(1,:))
call mul_matcrs_rv(obs%coeff_vF,vF(2,:),node,vF_obs(2,:))
call mul_matcrs_rv(obs%coeff_vF,vF(3,:),node,vF_obs(3,:))
if (g_param%iflagspherical .eq. 1) then
 call vectorspherical2xyz(obs%lonlatalt,vF_obs,nobs) ! m_spherical.f90
end if

!# set output
do i=1,nobs
 vfxyz(i,1:3) = vF_obs(1:3,i) * 1.d-6 ! 10^-12 V/m -> [mV/km]
 exyz_total(i,1:3)= exyz(i,1:3) + vfxyz(i,1:3) ![mV/km]
end do

return
end

!###################################################################
!# Note em_mesh%cmodel is not reflected now 2018.11.14
!# Coded on 2016.11.20 to visualize the electric current in the ocean
subroutine IXYHOUT(obs,exyz,h_ocean,it,g_param,iflag)
use constants
use matrix
use obs_type
use spherical
use oceanFvxyz
use outerinnerproduct
use param
implicit none
integer(4),          intent(in)    :: it, iflag! 0 for coordinate file, 1 for nothing
type(obs_info),      intent(in)    :: obs
type(param_forward), intent(in)    :: g_param
type(ocean_data),    intent(in)    :: h_ocean
real(8),             intent(in)    :: exyz(obs%nobs,3) ! [uV/m]
real(8),allocatable,dimension(:,:) :: Fxyz,vxyz,vF,vF_obs,ixyh
character(6)                       :: num
real(8),allocatable,dimension(:)   :: h
real(8)                            :: x2(2),x3(3,3),exyh,phaseE2N,sigma_ocean
integer(4)                         ::  i,j,nobs,node
character(70)                      :: outputfolder ! 2018.11.14
integer(4)                         :: lenout       ! 2018.11.14

!#[0]## set h
outputfolder   = g_param%outexyzfolder   ! 2018.11.14
lenout         = len_trim(outputfolder)  ! 2018.11.14
nobs           = obs%nobs
node           = h_ocean%node
allocate(Fxyz(3,node),vxyz(3,node),vF(3,node),vF_obs(3,nobs),ixyh(2,nobs))
Fxyz           = h_ocean%Fxyz  ! [nT]
vxyz           = h_ocean%vxyz  ! [mm/sec]
sigma_ocean    = g_param%cond(2) ! conductivity of ocean [S/m] should be modified!! 2018.11.14
allocate(h(nobs))
do i=1,nobs
  h(i) = - obs%xyz_obs(3,i) ! [km]
  if (h(i) .le. 0.d0 ) h(i) = 0.d0 ! when on land
end do

!#[1]## calculate
 do i=1,node
  vF(:,i)=outer(vxyz(:,i),Fxyz(:,i))
 end do
 call mul_matcrs_rv(obs%coeff_vF,vF(1,:),node,vF_obs(1,:))
 call mul_matcrs_rv(obs%coeff_vF,vF(2,:),node,vF_obs(2,:))
 call mul_matcrs_rv(obs%coeff_vF,vF(3,:),node,vF_obs(3,:))
 if (g_param%iflagspherical .eq. 1) then
  call vectorspherical2xyz(obs%lonlatalt,vF_obs,nobs) ! m_spherical.f90
 end if
 do i=1,nobs
  ![S/m] * [km] * [uV/m] = [A/km]
  ixyh(1:2,i)= sigma_ocean*h(i)*(exyz(i,1:2) + vF_obs(1:2,i)*1.d-6)
 end do

!#[1]## coordinate
if (iflag .eq. 0) then
 open(1,file=outputfolder(1:lenout)//"coord_"//obs%name(1:4)//".dat")
 write(1,*) nobs
 do i=1,nobs
  write(1,'(3g15.7)') (obs%xyz_obs(j,i),j=1,3)
 end do
end if

!#[3]## output bxyz
write(num,'(i6.6)') it
 open(1,file=outputfolder(1:lenout)//"ixyh_"//obs%name(1:4)//num(1:6)//".dat")
 do i=1,nobs
  exyh = sqrt(ixyh(1,i)**2.d0 + ixyh(2,i)**2.d0)![uV/m]*[km]
  phaseE2N    = atan2(ixyh(2,i),ixyh(1,i))*r2d ! [deg]
  write(1,*) exyh,phaseE2N
 end do
close(1)

return
end

!###################################################################
subroutine EBXYZOUT(obs,ebxyz,it,iebflag,iflag,g_param)
!# iebflag=1 for electric field, iebflag=2 for magnetic field
use param     ! 2018.11.14
use mesh_type
use obs_type
implicit none
type(param_forward), intent(in) :: g_param ! 2018.11.14
integer(4),          intent(in) :: iebflag
integer(4),          intent(in) :: it
integer(4),          intent(in) :: iflag ! 0 for coordinate file, 1 for nothing
type(obs_info),      intent(in) :: obs
real(8),             intent(in) :: ebxyz(obs%nobs,3)
character(6)                    :: num
real(8)                         :: x2(2),x3(3,3)
integer(4)                      ::  i,j
integer(4)                      :: lenbxyz, lenexyz ! 2018.11.14
character(70)                   :: outbxyz, outexyz ! 2018.11.14

!# set
 outbxyz = g_param%outbxyzfolder   ! 2018.11.14
 outexyz = g_param%outexyzfolder   ! 2018.11.14
 lenbxyz = len_trim(outbxyz)       ! 2018.11.14
 lenexyz = len_trim(outexyz)       ! 2018.11.14

!#[1]## coordinate
 if (iflag .eq. 0) then
  if (iebflag .eq. 1 ) open(1,file=outexyz(1:lenexyz)//"coord_"//obs%name(1:4)//".dat") ! 2018.11.14
  if (iebflag .eq. 2 ) open(1,file=outbxyz(1:lenbxyz)//"coord_"//obs%name(1:4)//".dat") ! 2018.11.14
  write(1,*) obs%nobs
  do i=1,obs%nobs
   write(1,'(3g15.7)') (obs%xyz_obs(j,i),j=1,3)
  end do
 end if

!#[2]## output bxyz
write(num,'(i6.6)') it
if (iebflag .eq. 1 )open(1,file=outexyz(1:lenexyz)//"exyz_"//obs%name(1:4)//num(1:6)//".dat")!2018.11.14
if (iebflag .eq. 2 )open(1,file=outbxyz(1:lenbxyz)//"bxyz_"//obs%name(1:4)//num(1:6)//".dat")!2018.11.14
do i=1,obs%nobs
 write(1,*) ebxyz(i,1:3)
end do
close(1)

return
end
!##################################################################### set_table_dof
! Coded on Feb 15, 2016
subroutine set_table_dof(dofn,nodtot,table_dof,doftot_ip)
implicit none
	integer(4),intent(in) :: dofn, nodtot, doftot_ip
	integer(4),intent(out) :: table_dof(nodtot,dofn)
	integer(4) :: i,j,dof_id
	dof_id=0
	do i=1,nodtot
       do j=1,dofn
	  dof_id = dof_id + 1
	  table_dof(i,j)= dof_id
       end do
	end do
	if (dof_id .ne. doftot_ip ) then
       write(*,*) "GEGEGE dof_id=",dof_id,"doftot_ip=",doftot_ip
	 stop
	end if
	write(*,*) "### SET TABLE_DOF END!! ###"
return
end

!####################################################### OBSLONLAT2XYZ
subroutine OBSLONLAT2XYZ(g_param,g_meshpara)
use param
use param_mesh
use constants
implicit none
type(param_forward),intent(inout) :: g_param
type(meshpara),     intent(in)    :: g_meshpara
integer(4) :: lonlatflag,nobs,i
real(8)    :: lonlataltobs(3,g_param%nobs),xyzobs(3,g_param%nobs),lonorigin,latorigin


 !#[1]## set input
 lonlatflag   = g_param%lonlatflag
 nobs         = g_param%nobs
 lonlataltobs = g_param%lonlataltobs
 lonorigin    = g_meshpara%lonorigin
 latorigin    = g_meshpara%latorigin

if ( lonlatflag .eq. 1 ) then ! longitude and latitude [deg] are given

!#[2]## calculation
 do i=1, nobs
   xyzobs(1,i) = (lonlataltobs(1,i) - lonorigin ) * d2r * earthrad*dcos(latorigin*d2r)
   xyzobs(2,i) = (lonlataltobs(2,i) - latorigin ) * d2r * earthrad
   xyzobs(3,i) =  lonlataltobs(3,i) ! upward [km]
   write(*,'(i3,a,i3,a,3g15.7)') i,"/",nobs," lonlataltobs(1:3)=",lonlataltobs(1:3,i)
   write(*,'(a,3g15.7)') "-> xyzobs(1:3,i)=",xyzobs(1:3,i)
 end do

 !#[3]## set output
 g_param%xyzobs = xyzobs

end if

return
end

!####################################################### PREPOBSCOEFF_XYSBTM
! copied from ../FEM_node/n_bzfem.f90
! adjusted to edge-FEM code
subroutine PREPOBSCOEFF_XYSBTM(em_mesh,l_line,obs_xy,ki_mesh,g_param)
use param ! include lonorigin and latorigin on 2016.11.20
use mesh_type
use line_type
use matrix
use obs_type
use fem_edge_util
use spherical ! added on 2016.11.20
implicit none
type(mesh),             intent(in)     :: em_mesh
type(line_info),        intent(in)     :: l_line
type(param_forward),    intent(in)     :: g_param
type(obs_info),         intent(inout)  :: obs_xy
type(mesh),             intent(in)     :: ki_mesh
type(grid_list_type)                   :: glist
integer(4),allocatable, dimension(:,:) :: n3
integer(4)                             :: ki23dptr(2,g_param%nodek) ! 2021.07.27
integer(4)                             :: nmax,i,j,k,ndat
real(8)                                :: xyz(3,em_mesh%node)
integer(4)                             :: nodes,ntets, ntrik,ntet,nodek
real(8)                                :: x3(3),lonorigin,latorigin
real(8)                                :: xyzminmax(6)
integer(4)                             :: nx,ny,nz

!#[0]## read ki_mesh and set input
   allocate ( n3(ki_mesh%ntri,3) )
   nodek     = ki_mesh%node
   ntrik     = ki_mesh%ntri
   n3        = ki_mesh%n3
   ki23dptr  = g_param%ki23dptr  ! 2021.07.27
   xyz       = em_mesh%xyz
   obs_xy%nobs=ntrik
   obs_xy%name="xy2D"
   lonorigin = g_param%lonorigin ! added pn 2016.11.20
   latorigin = g_param%latorigin ! added on 2016.11.20
   xyzminmax = g_param%xyzminmax

!#[1-1]# prepare coordinate of observatories for seafloor
  CALL allocate_real_crs_with_steady_ncolm(obs_xy%coeff_vF,ntrik,3) ! 2016.11.20
  allocate(obs_xy%xyz_obs(3,ntrik))
  write(*,*) "ntri of ki_mesh=",ntrik
  do i=1,ntrik
   x3(:)=0.d0
   do j=1,3
     k=n3(i,j) ! k is horizontal node id, ki23dptr(i,:), where i=1 surface, i=2 for seafloor
     x3(1:3) = x3(1:3) + xyz(1:3,ki23dptr(2,k))/3.d0 + (/0.d0,0.d0,0.001d0/)/3.d0 !1 m above seafloor/ground
     obs_xy%coeff_vF%item((i-1)*3+j)=ki23dptr(2,k) ! 2016.11.20 1 -> 2, 2021.07.27
     obs_xy%coeff_vF%val ((i-1)*3+j)=1/3.d0        ! 2016.11.20
   end do
     obs_xy%coeff_vF%stack(i)=3*i                  ! 2016.11.20
     obs_xy%xyz_obs(1:3,i)=x3(1:3)
  end do

!#[OPTION]## iflagspherical = 1  ##
  if ( g_param%iflagspherical .eq. 1 ) then   ! 2021.07.27
    allocate( obs_xy%xyzspherical(3,ntrik) )  ! added on 2016.11.19
    allocate( obs_xy%lonlatalt(3,ntrik)    )  ! added on 2016.11.19
    do i=1,ntrik
     call xyz2lonlatalt(obs_xy%xyz_obs(:,i),lonorigin,latorigin,obs_xy%lonlatalt(:,i))
     call lonlatalt2xyzspherical(obs_xy%lonlatalt(:,i),obs_xy%xyzspherical(:,i))
!    write(*,*) "obs_xy%lonlatalt(1:3,i)=",obs_xy%lonlatalt(1:3,i)
!    write(*,*) "obs_xy%xyzspherical(1:3,i)=",obs_xy%xyzspherical(1:3,i)
    end do
  end if

!#[2-2]## generate horizontal grid and classify all the elements to gridded boxes
nx=300;ny=300;nz=50
ntet=em_mesh%ntet
CALL allocate_grid_list(nx,ny,nz,ntet,glist) ! see m_mesh_type.f90
CALL gengridforlist(xyzminmax,glist)         ! see m_mesh_type.f90
CALL classifyelement2grd(em_mesh,glist)      ! classify ele to glist,see m_mesh_type.f90
write(*,*) "categolize elements end"

!#[3]# allocate coeffobs and calculate
!cal coeffobs(1:2,1:3)
CALL CALCOEFF_LINE(em_mesh,l_line,glist,obs_xy,g_param%iflagspherical)

write(*,*) "### PREPOBSCOEFF_XYSBTM END!! ###"
return
end

!####################################################### PREPOBSCOEFF_XY
! copied from PREPOBSCOEFF_YZ on June 14, 2016
!
! copied from ../FEM_node/n_bzfem.f90
! adjusted to edge-FEM code
subroutine PREPOBSCOEFF_XY(em_mesh,l_line,obs_xy,ki_mesh,g_param)
use param
use mesh_type
use line_type
use matrix
use obs_type
use fem_edge_util
use spherical
implicit none
!integer(4),intent(in) :: nobs ! # observatory
type(param_forward),   intent(in)     :: g_param
type(mesh),            intent(in)     :: em_mesh
type(line_info),       intent(in)     :: l_line
type(obs_info),        intent(out)    :: obs_xy
type(grid_list_type)                  :: glist
type(mesh),            intent(in)     :: ki_mesh
real(8),   allocatable,dimension(:)   :: zobs
integer(4)                            :: ki23dptr(2,g_param%nodek) ! 2021.07.27
real(8)    :: xyzminmax(6)
integer(4) :: nx,ny,nz ! please lower if corresponding element was not found
integer(4) :: ntet,i,j,ii,nobs,ndat,nodek,ixydepth
real(8)    :: x3(3),xmin,xmax,ymin,ymax,dx,dy,lonorigin,latorigin
integer(4) :: nnx,nny,nnz=1 ! vertical plane
integer(4) :: iflag    ! for PREPZOBS 2021.07.27
real(8)    :: z1 ! [km] for depth of xy plane

!#[0]## set input
 nodek          = g_param%nodek     ! 2021.07.27
 ki23dptr       = g_param%ki23dptr  ! 2021.07.27
 z1             = g_param%depth_xy  ! [km]
 ixydepth       = g_param%ixydepth
 nnx            = g_param%nx
 nny            = g_param%ny
 nobs           = nnx*nny
 obs_xy%nobs    = nobs
 obs_xy%name    = "xy2D"
 lonorigin      = g_param%lonorigin           ! 2016.11.20
 latorigin      = g_param%latorigin           ! 2016.11.20
 xyzminmax      = g_param%xyzminmax           ! 2016.11.20
 xmin           = xyzminmax(1)
 xmax           = xyzminmax(2)
 ymin           = xyzminmax(3)
 ymax           = xyzminmax(4)

!#[1-1]# prepare coordinate of observatories for seafloor
 allocate(obs_xy%xyz_obs(3,nobs))
 write(*,*) "nobs=",nobs
 dx=(xmax - xmin)/float(nnx)
 dy=(ymax - ymin)/float(nny)
 do j=1,nnx
  do i=1,nny
   ii=(j-1)*nny + i
   obs_xy%xyz_obs(1,ii)=(j-1)*dx + xmin + dx/2.d0
   obs_xy%xyz_obs(2,ii)=(i-1)*dy + ymin + dy/2.d0
   obs_xy%xyz_obs(3,ii)=z1 ! corresponds to g_param%ixydepth = 1
  end do
 end do

!#[OPTION]## if ixydepth = 2, modify the z coordinate of observatory
  !#[O-1]## read ki_mesh and set input added on 2016.11.20
  if (ixydepth .eq. 2) then
   allocate(zobs(nobs) )
   !#[O-3]## modify zcoordinate of obs 1m beneath the seafloor
    iflag = 1 ! 0 : without vf_coeff, 1 : for getting vf_coeff
    CALL PREPZOBS(obs_xy,em_mesh,ki_mesh,ki23dptr,g_param,iflag) ! 2021.07.26
   end if

!#[OPTION]## iflagspherical = 1  ##
  if ( g_param%iflagspherical .eq. 1 ) then ! 2021.07.27
    allocate(obs_xy%xyzspherical(3,nobs))   ! added on 2016.11.19
    allocate(obs_xy%lonlatalt(3,nobs)   )   ! added on 2016.11.19
    do i=1,nobs
     call xyz2lonlatalt(obs_xy%xyz_obs(:,i),lonorigin,latorigin,obs_xy%lonlatalt(:,i))
     call lonlatalt2xyzspherical(obs_xy%lonlatalt(:,i),obs_xy%xyzspherical(:,i))
    end do
  end if

!#[2-2]## generate horizontal grid and classify all the elements to gridded boxes
ntet = em_mesh%ntet
nx=300;ny=300;nz=50
CALL allocate_grid_list(nx,ny,nz,ntet,glist)   ! see m_mesh_type.f90
CALL gengridforlist(xyzminmax,glist) ! see m_mesh_type.f90
CALL classifyelement2grd(em_mesh,glist)   ! classify ele to glist,see m_mesh_type.f90
write(*,*) "categolize elements end"

!#[3]# allocate coeffobs and calculate
CALL CALCOEFF_LINE(em_mesh,l_line,glist,obs_xy,g_param%iflagspherical) ! cal coeffobs(1:2,1:3)

write(*,*) "### PREPOBSCOEFF_XY END!! ###"
return
99 continue
 write(*,*) "GEGEGE! ndat=",ndat,"is not equal to nodek",nodek,"PREPOBSCOEFF_XY"
 stop
end

!####################################################### PREPOBSCOEFF_YZ
! copied from ../FEM_node/n_bzfem.f90
! adjusted to edge-FEM code
subroutine PREPOBSCOEFF_YZ(em_mesh,l_line,obs_yz,g_param)
use param
use mesh_type
use line_type
use matrix
use obs_type
use fem_edge_util
implicit none
!integer(4),intent(in) :: nobs ! # observatory
type(mesh),           intent(in)  :: em_mesh
type(line_info),      intent(in)  :: l_line
type(param_forward),  intent(in)  :: g_param
type(obs_info),       intent(out) :: obs_yz
real(8)                           :: xyzminmax(6)
! (1,(1,2,3)) for edge basis fun (x,y,z), (2,(1,2,3)) for face basis fun
integer(4),           parameter :: nx=300,ny=300,nz=50 ! please lower if corresponding element was not found
!# internal variables
type(grid_list_type)              :: glist
integer(4)                        :: ntet,i,j,ii,nobs
real(8)                           :: x3(3),ymin,ymax,zmin,zmax,dy,dz
integer(4)                        :: nnx=1,nny=150,nnz=150 ! vertical plane
real(8),              parameter   :: x=0.d0 ! [km]
nobs=nny*nnz
obs_yz%nobs=nobs
obs_yz%name="yz2D"
xyzminmax = g_param%xyzminmax
ymin=xyzminmax(3)
ymax=xyzminmax(4)
zmin=xyzminmax(5)
zmax=xyzminmax(6)

!#[1-1]# prepare coordinate of observatories for seafloor
allocate(obs_yz%xyz_obs(3,nny*nnz))
write(*,*) "nobs=",nobs
dy=(ymax - ymin)/float(nny)
dz=(zmax - zmin)/float(nnz)
do j=1,nnz
 do i=1,nny
  ii=(j-1)*nny + i
  obs_yz%xyz_obs(1,ii)=x
  obs_yz%xyz_obs(2,ii)=(i-1)*dy + ymin + dy/2.d0
  obs_yz%xyz_obs(3,ii)=(j-1)*dz + zmin + dz/2.d0
 end do
end do

!#[2-2]## generate horizontal grid and classify all the elements to gridded boxes
ntet=em_mesh%ntet
write(*,*) "em_mesh%ntet=",em_mesh%ntet,"nx,ny,nz=",nx,ny,nz
CALL allocate_grid_list(nx,ny,nz,ntet,glist)   ! see m_mesh_type.f90
CALL gengridforlist(xyzminmax,glist) ! see m_mesh_type.f90
CALL classifyelement2grd(em_mesh,glist)   ! classify ele to glist,see m_mesh_type.f90
write(*,*) "categolize elements end"

!#[3]# allocate coeffobs and calculate
CALL CALCOEFF_LINE(em_mesh,l_line,glist,obs_yz) ! cal coeffobs(1:2,1:3)

write(*,*) "### PREPOBSCOEFF_YZ END!! ###"
return
end

!############################################## cal coeff for observatories
!# iflagspherical is added on 2016.11.20
!# coded on May 20, 2016
!# coeff_line(1,1:3) for A = [edge_basis_fun]{Al}
!# coeff_line(2,1:3) for B = [face_basis_fun]{Al}
subroutine CALCOEFF_LINE(h_mesh,l_line,glist,obs,iflagspherical)
use mesh_type
use matrix
use line_type
use obs_type
use fem_edge_util
use spherical ! added on 2016.11.20
implicit none
type(mesh),          intent(in)    :: h_mesh
type(line_info),     intent(in)    :: l_line
type(grid_list_type),intent(in)    :: glist
integer(4), optional,intent(in)    :: iflagspherical
type(obs_info),      intent(inout) :: obs
real(8),allocatable,dimension(:,:) :: xyz,xyz_obs
real(8),allocatable,dimension(:,:) :: xyzspherical,xyzspherical_obs

!# internal variables
integer(4) :: i,j,l,nrow,ncolm,ii,jj,iele,n6(6),iflag
real(8) :: x3(3),elm_xyz(3,4),r6(6),w(3,6),wfe(3,6),len(6),v,a4(4),coeff(3,6),coeff_rot(3,6)
real(8) :: coeff_s(3,6),coeff_rot_s(3,6),sphe2xyz(3,3)

!#[0]## set ### added on 2016.11.20
if (      present(iflagspherical)) iflag = iflagspherical
if (.not. present(iflagspherical)) iflag = 0
write(*,*) "iflag=",iflag
allocate(xyz(3,h_mesh%node),xyz_obs(3,obs%nobs))
! normal
 xyz = h_mesh%xyz
 xyz_obs = obs%xyz_obs
if (iflag .eq. 1) then ! spherical
 allocate(xyzspherical(3,h_mesh%node),xyzspherical_obs(3,obs%nobs))
 xyzspherical = h_mesh%xyzspherical
 xyzspherical_obs = obs%xyzspherical
end if

!#[1]## allocate coeff_line #
nrow=obs%nobs
ncolm=6
do i=1,2 ; do j=1,3
 CALL allocate_real_crs_with_steady_ncolm(obs%coeff(i,j),nrow,ncolm) ! see m_matrix.f90
end do ; end do

!#[2]## find element with glist with "normal mesh"
do i=1,obs%nobs
  if (mod(i,10000) .eq. 0 ) write(*,*) "i=",i
!  write(*,*) "i-th triangle",i,"ntrik=",ntrik
  x3(1:3)=xyz_obs(1:3,i)
  CALL FINDELEWITHGRID(h_mesh,glist,x3,iele,a4) ! see m_mesh_type.f90
!  write(*,*) i,"/",obs%nobs,"x3=",x3(1:3)

  !#[2-3]##
  if (iflag .eq. 1)   x3(1:3)=xyzspherical_obs(1:3,i) ! spherical case
  do j=1,4
    elm_xyz(1:3,j)=xyz(1:3,h_mesh%n4(iele,j))
    ! spherical case
    if (iflag .eq. 1) elm_xyz(1:3,j)=xyzspherical(1:3,h_mesh%n4(iele,j))
  end do
!  write(*,'(3g15.7)') (elm_xyz(1:3,j),j=1,4)

  CALL EDGEBASISFUN(elm_xyz,x3,w,len,v) !v[km]^3,w[1/km],len[km],see m_fem_edge_util.f90
  CALL FACEBASISFUN(elm_xyz,x3,wfe,v) !v[km]^3,w[1/km],len[km],see m_fem_edge_util.f90
  do j=1,6
   ! coeff is values for line-integrated value
   coeff(1:3,j)     =   w(1:3,j) * isign(1,l_line%n6line(iele,j)) ! for icom-th component
   coeff_rot(1:3,j) = wfe(1:3,j) * isign(1,l_line%n6line(iele,j)) ! for icom-th component
   r6(j)=abs(l_line%n6line(iele,j))*1.d0
  end do
  n6(1:6)=(/1,2,3,4,5,6/)
  call SORT_INDEX(6,n6,r6) !sort n4 index by r4 : see sort_index.f90

  !# SPHERICAL OPTION ## added on 2016.11.20
  if ( iflag .eq. 1) then
   call tensorsphe2xyz(obs%lonlatalt(:,i),sphe2xyz)
   call mul_ab(sphe2xyz,coeff,    coeff_s,    3,3,6)
   call mul_ab(sphe2xyz,coeff_rot,coeff_rot_s,3,3,6)
   coeff = coeff_s
   coeff_rot = coeff_rot_s
  end if

  do j=1,6
   jj=abs(l_line%n6line(iele,n6(j))) ! jj is global node id
   ii=(i-1)*6+j                  ! ii is entry id for coeffobs matrix
   do l=1,3 ! l-th component
    obs%coeff(1,l)%item(ii)=jj
    obs%coeff(2,l)%item(ii)=jj
    obs%coeff(1,l)%val(ii)=    coeff(l,n6(j)) ! for x component
    obs%coeff(2,l)%val(ii)=coeff_rot(l,n6(j)) ! for x component
   end do
  end do
end do

return
end
